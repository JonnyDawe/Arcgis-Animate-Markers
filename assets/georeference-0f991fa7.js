import{gC as ir,gN as sr,bX as lr,f as T,g as $,F as cr,aQ as fr,a5 as _,b$ as ur,gO as pr,gP as D,gQ as W,gR as w,gS as gr,gT as V,gU as yr,bg as mr,r as B,gV as hr,gW as Tr,gX as L,J as $r,gY as q,fL as k,fK as J,gZ as Ar,gI as Pr,g_ as Fr,g$ as dr,h0 as Er,l as m,h1 as C,h2 as H,h3 as Mr,bj as Rr,h4 as vr,h5 as xr}from"./vendor-8b656dfb.js";import{e as K}from"./mat3f64-221ce671.js";import{e as A,o as _r}from"./mat4f64-1413b4a7.js";import{c as M}from"./spatialReferenceEllipsoidUtils-8fff29a8.js";import{v as S,y as wr,x as Cr}from"./quat-1db7cb78.js";import{e as I}from"./quatf64-3363c48e.js";import{T as p,i as u}from"./BufferView-d8a17df5.js";import{t as d,e as br,r as P,o as rr}from"./vec33-1e5ac6fd.js";function E(r=Or){return[r[0],r[1],r[2],r[3]]}function ut(r,t,e=E()){return ir(e,r),e[3]=t,e}function pt(r,t,e=E()){return S(R,r,z(r)),S(Q,t,z(t)),wr(R,Q,R),Nr(e,sr(Cr(e,R)))}function gt(r){return r}function z(r){return lr(r[3])}function Nr(r,t){return r[3]=t,r}const Or=[0,0,1,0],R=I(),Q=I();E();var Y;let y=Y=class extends fr{constructor(r){super(r),this.origin=_(),this.translation=_(),this.rotation=E(),this.scale=ur(1,1,1),this.geographic=!0}get localMatrix(){const r=A();return S(X,this.rotation,z(this.rotation)),pr(r,X,this.translation,this.scale),r}get localMatrixInverse(){return D(A(),this.localMatrix)}applyLocal(r,t){return W(t,r,this.localMatrix)}applyLocalInverse(r,t){return W(t,r,this.localMatrixInverse)}project(r,t){const e=new Float64Array(r.length),o=p.fromTypedArray(e),n=p.fromTypedArray(r);if(this.geographic){const l=M(t),c=A();return w(t,this.origin,c,l),gr(c,c,this.localMatrix),d(o,n,c),V(e,l,0,e,t,0,e.length/3),e}const{localMatrix:a,origin:i}=this;yr(a,_r)?br(o,n):d(o,n,a);for(let l=0;l<e.length;l+=3)e[l+0]+=i[0],e[l+1]+=i[1],e[l+2]+=i[2];return e}getOriginPoint(r){const[t,e,o]=this.origin;return new mr({x:t,y:e,z:o,spatialReference:r})}equals(r){return B(r)&&this.geographic===r.geographic&&hr(this.origin,r.origin)&&Tr(this.localMatrix,r.localMatrix)}clone(){const r={origin:L(this.origin),translation:L(this.translation),rotation:E(this.rotation),scale:L(this.scale),geographic:this.geographic};return new Y(r)}};T([$({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"origin",void 0),T([$({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"translation",void 0),T([$({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"rotation",void 0),T([$({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"scale",void 0),T([$({type:Boolean,nonNullable:!0,json:{write:!0}})],y.prototype,"geographic",void 0),T([$()],y.prototype,"localMatrix",null),T([$()],y.prototype,"localMatrixInverse",null),y=Y=T([cr("esri.geometry.support.MeshTransform")],y);const X=I(),Lr=y;function G(r,t){return r.isGeographic||r.isWebMercator&&((t==null?void 0:t.geographic)??!0)}const b=$r.getLogger("esri.geometry.support.meshUtils.normalProjection");function Br(r,t,e,o,n){return O(o)?(N(h.TO_PCPF,u.fromTypedArray(r),p.fromTypedArray(t),p.fromTypedArray(e),o,u.fromTypedArray(n)),n):(b.error("Cannot convert spatial reference to PCPF"),n)}function Sr(r,t,e,o,n){return O(o)?(N(h.FROM_PCPF,u.fromTypedArray(r),p.fromTypedArray(t),p.fromTypedArray(e),o,u.fromTypedArray(n)),n):(b.error("Cannot convert to spatial reference from PCPF"),n)}function zr(r,t,e){return V(r,t,0,e,M(t),0,r.length/3),e}function Yr(r,t,e){return V(r,M(e),0,t,e,0,r.length/3),t}function jr(r,t,e){if(m(r))return t;const o=p.fromTypedArray(r),n=p.fromTypedArray(t);return d(n,o,e),t}function Vr(r,t,e){if(m(r))return t;C(f,e);const o=u.fromTypedArray(r),n=u.fromTypedArray(t);return P(n,o,f),H(f)||rr(n,n),t}function Ir(r,t,e){if(m(r))return t;C(f,e);const o=u.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),n=u.fromTypedArray(t,4*Float32Array.BYTES_PER_ELEMENT);if(P(n,o,f),H(f)||rr(n,n),r!==t)for(let a=3;a<r.length;a+=4)t[a]=r[a];return t}function Gr(r,t,e,o,n){if(!O(o))return b.error("Cannot convert spatial reference to PCPF"),n;N(h.TO_PCPF,u.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),p.fromTypedArray(t),p.fromTypedArray(e),o,u.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT));for(let a=3;a<r.length;a+=4)n[a]=r[a];return n}function Ur(r,t,e,o,n){if(!O(o))return b.error("Cannot convert to spatial reference from PCPF"),n;N(h.FROM_PCPF,u.fromTypedArray(r,16),p.fromTypedArray(t),p.fromTypedArray(e),o,u.fromTypedArray(n,16));for(let a=3;a<r.length;a+=4)n[a]=r[a];return n}function N(r,t,e,o,n,a){if(!t)return;const i=e.count,l=M(n);if(tr(n))for(let c=0;c<i;c++)o.getVec(c,v),t.getVec(c,g),w(l,v,x,l),q(f,x),r===h.FROM_PCPF&&k(f,f),J(g,g,f),a.setVec(c,g);else for(let c=0;c<i;c++){o.getVec(c,v),t.getVec(c,g),w(l,v,x,l),q(f,x);const F=Ar(e.get(c,1));let s=Math.cos(F);r===h.TO_PCPF&&(s=1/s),f[0]*=s,f[1]*=s,f[2]*=s,f[3]*=s,f[4]*=s,f[5]*=s,r===h.FROM_PCPF&&k(f,f),J(g,g,f),Pr(g,g),a.setVec(c,g)}return a}function O(r){return tr(r)||Wr(r)}function tr(r){return r.isWGS84||Fr(r)||dr(r)||Er(r)}function Wr(r){return r.isWebMercator}var h;(function(r){r[r.TO_PCPF=0]="TO_PCPF",r[r.FROM_PCPF=1]="FROM_PCPF"})(h||(h={}));const v=_(),g=_(),x=A(),f=K();function er(r,t,e){return G(t.spatialReference,e)?Jr(r,t,e):kr(r,t,e)}function qr(r,t,e){const{position:o,normal:n,tangent:a}=r;if(m(t))return{position:o,normal:n,tangent:a};const i=t.localMatrix;return er({position:jr(o,new Float64Array(o.length),i),normal:B(n)?Vr(n,new Float32Array(n.length),i):null,tangent:B(a)?Ir(a,new Float32Array(a.length),i):null},t.getOriginPoint(e),{geographic:t.geographic})}function yt(r,t,e){if(e!=null&&e.useTransform){const{position:o,normal:n,tangent:a}=r;return{vertexAttributes:{position:o,normal:n,tangent:a},transform:new Lr({origin:[t.x,t.y,t.z??0],geographic:G(t.spatialReference,e)})}}return{vertexAttributes:er(r,t,e),transform:null}}function Z(r,t,e){return G(t.spatialReference,e)?Dr(r,t,e):nr(r,t,e)}function mt(r,t,e,o){if(m(t))return Z(r,e,o);const n=qr(r,t,e.spatialReference);return e.equals(t.getOriginPoint(e.spatialReference))?nr(n,e,o):Z(n,e,o)}function kr(r,t,e){const o=new Float64Array(r.position.length),n=r.position,a=t.x,i=t.y,l=t.z||0,{horizontal:c,vertical:F}=U(e?e.unit:null,t.spatialReference);for(let s=0;s<n.length;s+=3)o[s+0]=n[s+0]*c+a,o[s+1]=n[s+1]*c+i,o[s+2]=n[s+2]*F+l;return{position:o,normal:r.normal,tangent:r.tangent}}function Jr(r,t,e){const o=t.spatialReference,n=or(t,e,j),a=new Float64Array(r.position.length),i=Qr(r.position,n,o,a),l=C(ar,n);return{position:i,normal:Xr(i,a,r.normal,l,o),tangent:Zr(i,a,r.tangent,l,o)}}function Qr(r,t,e,o){d(p.fromTypedArray(o),p.fromTypedArray(r),t);const n=new Float64Array(r.length);return Yr(o,n,e)}function Xr(r,t,e,o,n){if(m(e))return null;const a=new Float32Array(e.length);return P(u.fromTypedArray(a),u.fromTypedArray(e),o),Sr(a,r,t,n,a),a}function Zr(r,t,e,o,n){if(m(e))return null;const a=new Float32Array(e.length);P(u.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT),u.fromTypedArray(e,4*Float32Array.BYTES_PER_ELEMENT),o);for(let i=3;i<a.length;i+=4)a[i]=e[i];return Ur(a,r,t,n,a),a}function nr(r,t,e){const o=new Float64Array(r.position.length),n=r.position,a=t.x,i=t.y,l=t.z||0,{horizontal:c,vertical:F}=U(e?e.unit:null,t.spatialReference);for(let s=0;s<n.length;s+=3)o[s+0]=(n[s+0]-a)/c,o[s+1]=(n[s+1]-i)/c,o[s+2]=(n[s+2]-l)/F;return{position:o,normal:r.normal,tangent:r.tangent}}function Dr(r,t,e){const o=t.spatialReference;or(t,e,j);const n=D(tt,j),a=new Float64Array(r.position.length),i=Hr(r.position,o,n,a),l=C(ar,n);return{position:i,normal:Kr(r.normal,r.position,a,o,l),tangent:rt(r.tangent,r.position,a,o,l)}}function or(r,t,e){w(r.spatialReference,[r.x,r.y,r.z||0],e,M(r.spatialReference));const{horizontal:o,vertical:n}=U(t?t.unit:null,r.spatialReference);return Mr(e,e,[o,o,n]),e}function Hr(r,t,e,o){const n=zr(r,t,o),a=p.fromTypedArray(n),i=new Float64Array(n.length),l=p.fromTypedArray(i);return d(l,a,e),i}function Kr(r,t,e,o,n){if(m(r))return null;const a=Br(r,t,e,o,new Float32Array(r.length)),i=u.fromTypedArray(a);return P(i,i,n),a}function rt(r,t,e,o,n){if(m(r))return null;const a=Gr(r,t,e,o,new Float32Array(r.length)),i=u.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT);return P(i,i,n),a}function U(r,t){if(m(r))return et;const e=t.isGeographic?1:Rr(t),o=t.isGeographic?1:vr(t),n=xr(1,r,"meters");return{horizontal:n*e,vertical:n*o}}const j=A(),tt=A(),ar=K(),et={horizontal:1,vertical:1};export{Ur as L,zr as M,Yr as R,yt as _,Gr as a,Z as b,E as c,z as d,ut as e,Lr as f,gt as g,Sr as h,mt as i,Br as j,qr as k,G as r,pt as v,er as x};
